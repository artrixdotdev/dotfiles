use clap::Parser;
use handlebars::{Handlebars, handlebars_helper};
use serde_json::Value;
use std::{collections::HashMap, env, fs, path::PathBuf};
use walkdir::WalkDir;

const DISCLAIMER: &str = r#"
// This file is AUTOGENERATED, do not edit it directly
//
"#;

/// A simple CLI tool to render Handlebars templates for Niri configurations.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    /// Root directory for all relative paths. Defaults to $HOME/dotfiles.
    #[arg(short, long)]
    root_dir: Option<PathBuf>,

    /// Path to the settings.json file, relative to root_dir.
    #[arg(short, long, default_value = "settings.json")]
    settings_file: PathBuf,

    /// Path to the directory containing Niri config Handlebars templates, relative to root_dir.
    #[arg(short, long, default_value = ".config/niri")]
    niri_dir: PathBuf,

    /// Path to the main config.kdl.hbs template, relative to root_dir.
    #[arg(short, long, default_value = "config.kdl.hbs")]
    main_template: PathBuf,

    /// Path where the final config.kdl should be written, relative to root_dir.
    #[arg(short, long, default_value = "config.kdl")]
    output_file: PathBuf,
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    let root = args.root_dir.unwrap_or_else(|| {
        let home = env::var_os("HOME").unwrap_or_else(|| {
            eprintln!("WARN: HOME env var not found. Defaulting root_dir to current directory.");
            std::ffi::OsString::from(".")
        });
        PathBuf::from(home).join("dotfiles")
    });
    println!("Root directory: {}", root.display());

    let settings_path = root.join(&args.settings_file);
    let niri_dir = root.join(&args.niri_dir);
    let niri_cfg_dir = niri_dir.join("config");
    let main_tpl_path = niri_dir.join(&args.main_template);
    let output_path = niri_dir.join(&args.output_file);

    println!("Reading settings from: {}", settings_path.display());
    let settings_content = fs::read_to_string(&settings_path)?;
    let settings: Value = serde_json::from_str(&settings_content)?;

    let mut hb = Handlebars::new();
    hb.register_escape_fn(handlebars::no_escape);

    // Math helpers
    handlebars_helper!(mul: |a: f32, b: f32| a * b);
    handlebars_helper!(add: |a: f32, b: f32| a + b);
    handlebars_helper!(sub: |a: f32, b: f32| a - b);
    handlebars_helper!(div: |a: f32, b: f32| a / b);

    hb.register_helper("mul", Box::new(mul));
    hb.register_helper("add", Box::new(add));
    hb.register_helper("sub", Box::new(sub));
    hb.register_helper("div", Box::new(div));

    hb.set_prevent_indent(true);

    let mut configs: Vec<Value> = Vec::new();

    if !niri_cfg_dir.exists() || !niri_cfg_dir.is_dir() {
        return Err(format!(
            "Niri config directory not found or not a directory: {}",
            niri_cfg_dir.display()
        )
        .into());
    }
    println!("Processing templates in: {}", niri_cfg_dir.display());

    for entry in WalkDir::new(&niri_cfg_dir)
        .min_depth(1)
        .max_depth(1)
        .into_iter()
        .filter_map(|e| e.ok())
    {
        let path = entry.path();
        if path.is_file() && path.extension().map_or(false, |ext| ext == "kdl") {
            println!("Rendering template: {}", path.display());
            let mut data = HashMap::new();
            data.insert("settings", &settings);
            let tpl_content = fs::read_to_string(path)?;
            let rendered = hb.render_template(&tpl_content, &data)?;

            let cfg_obj = serde_json::json!({
                "path": path.strip_prefix(&niri_cfg_dir)
                            .unwrap_or(path)
                            .display()
                            .to_string(),
                "text": rendered,
            });
            configs.push(cfg_obj);
        }
    }

    println!("Rendering main template: {}", main_tpl_path.display());
    let main_tpl_content = fs::read_to_string(&main_tpl_path)?;

    let mut main_data = HashMap::new();
    main_data.insert("configs", serde_json::to_value(&configs)?);
    main_data.insert("settings", settings);
    let mut final_config = DISCLAIMER.to_string();
    final_config.push_str(&hb.render_template(&main_tpl_content, &main_data).unwrap());

    println!("Writing final config to: {}", output_path.display());
    fs::write(&output_path, final_config)?;

    println!(
        "config.kdl generated successfully at {}",
        output_path.display()
    );

    Ok(())
}
